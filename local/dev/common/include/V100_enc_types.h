/******************************<%BEGIN LICENSE%>******************************/
// (c) Copyright 2021 Lumidigm, part of HID Global  (Unpublished Copyright) ALL RIGHTS RESERVED.
//
// For a list of applicable patents and patents pending, visit www.lumidigm.com/patents/
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//
/******************************<%END LICENSE%>******************************/
#ifndef __V100_ENC_TYPES
#define __V100_ENC_TYPES
#include "lumi_stdint.h"
#include "V100_key_cache.h"

// Encrypted data structures.

#ifdef _VDSP
#pragma diag(suppress: 301)
#endif

#define KCV_LENGTH      4          // Key Check Value Length in Bytes
#define RSA_LENGTH      256        // RSA key length (2048 bits)
#define ANBIO_LENGTH    16         // Size of the Random Number generated by the Device
#define ANSOL_LENGTH    16         // Size of the Random Number generated by the trusted secure endpoint
#define BLOCK_LENGTH    16         // For Crypto the buffer needs be alligned of BLOCK_LENGTH

/*
**  Extended Key Area Keysizes
*/
#define ENC_KEY_SIZE_AES128        16
#define ENC_KEY_SIZE_AES256        32
#define ENC_KEY_SIZE_TDES128       16
#define ENC_KEY_SIZE_TDES192       24

#define ENC_PROC_IMAGE             0x01
#define ENC_PROC_TEMPLATE          0x02
#define ENC_PROC_SPOOF             0x04
#define ENC_PROC_LATENT            0x08
#define ENC_PROC_FINGER_LIFT       0x10

#define _V100_ENC_DIAG_STATUS_BOOT_VALIDATION_FAILED    1

// if set in uszBIRDataType field, the uszIndex field is present
#define    BioAPI_BIR_INDEX_PRESENT    (0x80)

constexpr uint MAX_VERIFY_RECORDS = 32;

// Enums

enum _V100_FIRMWARE_MODE
{
    FIRMWARE_MODE_LEGACY      = 0x00,
    FIRMWARE_MODE_UNLOCKED    = 0x01,
    FIRMWARE_MODE_LOCKED      = 0x02,
    FIRMWARE_MODE_SHIPPING    = 0x0B,
    FIRMWARE_MODE_PKI_SC      = 0x0C,
};

typedef _V100_FIRMWARE_MODE _V100_ENC_FIRMWARE_MODE;

// Please use _V100_CAPTURE_TYPE in V100_shared_types for _V100_ENC_CAPTURE_TYPE

enum _V100_ENC_SPOOF_PROTECTION_LEVEL
{
    SPOOF_PROTECT_DONT_CHANGE         = 0x00,
    SPOOF_PROTECT_NONE                = 0x10,
    SPOOF_PROTECT_HIGH_SECURE         = 0x11,
    SPOOF_PROTECT_MEDIUM_SECURE       = 0x12,
    SPOOF_PROTECT_CONVENIENT_SECURE   = 0x13,
};

typedef _V100_ENC_SPOOF_PROTECTION_LEVEL _V400_SPOOF_PROTECTION_LEVEL;

enum _V100_ENC_RECORD_MODE
{
    RAW_MODE = 0x00,        // Records will consist of just the biometric data as specified by the data type without
                            // wrapping such data in any specified structure (i.e. biometric template, WSQ compressed
                            // image, etc.)
    BIR_MODE = 0x01,        // Records will consist of the biometric data populated in a _V100_ENC_BIR structure
};

enum class V100_Enc_Record_Modes : int
{
    RAW_MODE = 0x00,    // Records will consist of just the biometric data as specified by the data type without
                        // wrapping such data in any specified structure (i.e. biometric template, WSQ compressed
                        // image, etc.)
    BIR_MODE = 0x01,    // Records will consist of the biometric data populated in a _V100_ENC_BIR structure
};

typedef _V100_ENC_RECORD_MODE _V100_TEMPLATE_RECORD_MODE;

enum _V100_ENC_THRESHOLD_MODE
{
    THRESHOLD_MODE_FAR = 0x00, // Default
    THRESHOLD_MODE_FRR = 0x01,
};

enum class V100_Enc_Threshold_Modes : int
{
    THRESHOLD_MODE_FAR = 0x00, // Default
    THRESHOLD_MODE_FRR = 0x01,
};

enum _V100_ENC_IMAGE_MODE
{
    IMAGE_RAW            = 0x00,
    IMAGE_WSQ_COMPRESSED = 0x01,
};

enum class V100_Enc_Image_Modes : int
{
    IMAGE_RAW            = 0x00,
    IMAGE_WSQ_COMPRESSED = 0x01,
};

/*
* Types of Crypto modes available
* This is used in VMTCommon project
*/
enum class V100_CRYPTO_MODE
{
    CRYPTO_UNLOCKED          = 0x0000,
    CRYPTO_LOCKED            = 0x0001,
    CRYPTO_AES               = 0x0002,
    CRYPTO_TDES              = 0x0003,
    CRYPTO_AES_ECB           = 0x0004,
    CRYPTO_AES_CBC           = 0x0005,
    CRYPTO_AES_CTR           = 0x0006,
    CRYPTO_SET_IVG_8         = 0x0007,
    CRYPTO_SET_IVG_16        = 0x0008,
    CRYPTO_SET_IVG_32        = 0x0009,
};

// Structs

// ISO BIR-related structs see below.

struct _V100_ENC_DIAG_STATUS
{
    u32   serial_number;
    u32   fw_rev;
    u32   lfd_rev;
    u32   smfw_rev;
    u32   fta_status;
    u32   bit_status;
    u32   tamper_status;
    u32   boot_validation;
    u32   authentication_status;
    u32   pd_exposure;
    u32   s1_exposure;
    u32   s2_exposure;
    u32   s3_exposure;
    u32   s4_exposure;
    u32   dark_exposure;
    u32   image_noise;
    u32   mpv_dark;
    u32   focus;
    u32   alignment;
    u32   latent_status;
    u32   retry_status;
    u32   mask_size;
    u32   key_status;
    u256  keySlotPopulated;
    u256  keySlotLocked;
    u32   reserved_1;
    u32   reserved_2;
    u32   reserved_3;
    u32   reserved_4;
    u32   reserved_5;
    u32   reserved_6;
    u32   reserved_7;
    u32   reserved_8;
};

struct _V100_ENC_SENSOR_INFO
{
    u128  nANSOL;                  // A random number generated by the secure host
    u64   nSerialNumber;          // The serial number of the unit
    u64   nHardwareUniqueID;    // 8-byte serial number of the hardware secure element
    u64   nVersion;                 // [ Zeros(2) FW_REV(2) HW_SEC_ELEMENT_Rev(2) Spoof_Rev(2)]
                                // MSB to LSB
    u8    zeropad[24];
};

struct _V100_ENC_IMAGE_REQ_HDR
{
    u128 nANSOL;            // Random number generated by trusted host
    u32  nImageType;          // What type of image to retrieve. Either IMAGE_COMPOSITE or IMAGE_WSQ
    u32  nBufferType;         // What data buffer to retrieve (_V100_ENC_CAPTURE_TYPE)
    u32  nRecordMode;          // How to wrap image data. Either RAW_RECORD or BIR_RECORD
    u32  nRecordHdrSize;    // The size of the record header that follows this request header
};

struct _V100_ENC_IMAGE_HDR
{
    u128 nANSOL;            // Random number generated by trusted host
    u32  nImageMode;          // The mode of the image data returned (_V100_ENC_IMAGE_MODE). Either IMAGE_RAW or IMAGE_WSQ_COMPRESSED
    u32  nRecordMode;          // How to wrap the image data(_V100_ENC_RECORD_MODE). Either RAW_RECORD or BIR_RECORD
    u32  nImageWidth;         // Image width (uncompressed)
    u32  nImageHeight;         // Image height (uncompressed)
    u32  nImageBPP;         // Image Format (Bits Per Pixel)
    u32  nSpoofScore;        // Spoof Score(u32 max will indicate spoof is turned off)
    u32  nImageDataSize;    // Image data size in bytes
};

struct _V100_ENC_MATCH_HDR
{
    u128  nANSOL;            // Random number generated by trusted host
    u128  nANBIO;            // Random number generated by the device
    u32   nTemplateMode;      // The format of the biometric template. Either ANSI or ISO
    u32   nRecordMode;      // How to wrap the template data. Either RAW_RECORD or BIR_RECORD
    u32   nRecordHdrSize;     // The size of the record header for each record
};

struct _V100_ENC_MATCH_RESULT_HDR
{
    u128  nANSOL;            // Random number generated by trusted host
    u32   nMatchResults;    // 1 is a Match, 0 is a non-match
    u32   nMatchScore;        // Resultant score of match.
};

struct _V100_ENC_PARAMETERS
{
    u16 nTimeoutSeconds;        // Capture timeout in seconds - Default read from policy file
    u16 nProcessingMode;        // Bitmask for sensor processing options. Includes Image Out, Template
                                // Out, Spoof Out, Latent On, etc. ), default is all on
    u16 nCropLevel;                // _V100_CROP_LEVEL. Default CROP_NONE
    u16 nWSQCompressionRatio;    // Max 20 and min 2. Default is 11
    u16 nSpoofProtectionLevel;    // _V100_ENC_SPOOF_PROTECTION_LEVEL. Default
                                // SPOOF_PROTECT_MEDIUM_SECURE. FRR % of real fingers in tenths of a %
    u16 nMaxTemplateSize;        // Maximum ANSI/ISO Template Size to be generated. Min 512 and Max 2048.
                                // Default - 2048 for no truncation.
    u16 nThresholdMode;            // _V100_ENC_THRESHOLD_MODE. FRR or FAR. Default
                                // THRESHOLD_MODE_FAR
    u16 nEnrollmentThreshold;    // Inter-enrollment threshold. 1-100 are valid values, default 1
                                // FAR/FRR(as selected in nThresholdMode) % in tenths of a %
    u16 nVerifyThreshold;        // Verification threshold. 1-100 are valid values, default 1.
                                // FAR/FRR(as selected in nThresholdMode) % in tenths of a %
    u16 nTemplateMode;            // _V100_TEMPLATE_MODE. Default is TEMPLATE_ANSI_378
    u16 nRecordMode;            // _V100_ENC_RECORD_MODE. Default is RAW_MODE
    u16 nImageMode;                // _V100_ENC_IMAGE_MODE. Default is IMAGE_RAW
    u8  zeropad[24];            // Reserved for future use
};

struct _V100_ENC_TEMPLATE_REQ_HDR
{
    u128 nANSOL;            // Random number generated by trusted host
    u32  nTemplateMode;     // The format of the biometric template (_V100_TEMPLATE_MODE). Either
                            // TEMPLATE_ANSI_378 or TEMPLATE_ISO_NORMAL
    u32  nBufferType;         // What data buffer to retrieve (_V100_ENC_CAPTURE_TYPE)
    u32  nRecordMode;          // How to wrap the template data(_V100_ENC_RECORD_MODE). Either RAW_RECORD or
                            // BIR_RECORD
    u32  nRecordHdrSize;    // The size of the record header that follows this request header
};

struct _V100_ENC_TEMPLATE_HDR
{
    u128 nANSOL;            // Random number generated by trusted host
    u32  nTemplateMode;     // The format of the biometric template (_V100_TEMPLATE_MODE). Either
                            // TEMPLATE_ANSI_378 or TEMPLATE_ISO_NORMAL
    u32  nRecordMode;          // How to wrap the template data(_V100_ENC_RECORD_MODE). Either RAW_RECORD or
                            // BIR_RECORD
    u32  nSpoofScore;        // Spoof Score (u32 max will indicate spoof is turned off)
    u32  nTemplateDataSize;    // Template data size in bytes
};

struct _V100_ENC_VERIFY_REQ_HDR
{
    u128  nANSOL;            // Random number generated by trusted host
    u128  nANBIO;            // Random number generated by the device
    u32   nTemplateMode;      // The format of the biometric template. Either ANSI or ISO
    u32   nRecordMode;      // How to wrap the template data. Either RAW_RECORD or BIR_RECORD
    u32   nNumRecords;        // How many records are provided to match against
};

struct _V100_ENC_VERIFY_RESULT_HDR
{
    u128  nANSOL;            // Random number generated by trusted host
    u32   nNumRecords;        // How many scores returned (i.e. how many records provided to the request)
    u32   nMatchResults;    // A bitmask representing which records matched(LSB right to left,
                            // represents record index 0)
};

#pragma pack(push)
#pragma pack(1)
struct _V100_KSN_TYPE
{
    u64 CNTR   : 21;    // right-most 21b Transaction Counter
    u64 DID    : 43;
    u16 INNMSB;            // Issuer Identifier Number
};
#pragma pack()
#pragma pack(pop)

struct _V100_ENC_SPOOF_RESULT
{
    u128 nANSOL;            // Random number generated by trusted host
    u32  nSpoofScore;        // Spoof Score (u32 max will indicate spoof is turned off)
};

#pragma pack(push)
#pragma pack(1)
struct ASN_KEY
{
    u8  Header[9];
    u8  Key[256];
    u8  Exp[3];
};
#pragma pack(pop)

struct _V100_VERIFY_RESULT_MATCH
{
    u128            ANSOL;
    unsigned int    MatchResult;    // Boolean 0 for no, Positive for yes.
    unsigned int    FMR;            // Match Score
    char            pad[8];
};


/**
 @brief This is the ISO-compliant version of the header structure of a BIR
 */
#pragma pack(push)
#pragma pack(1)
struct _V100_ENC_BIR_HEADER
{
    unsigned char  uszHdLength[4];         // Header Size + BiometricDataBlock + 4 bytes for zero SB
    unsigned char  uszHeaderVersion[1];
    unsigned char  uszBIRDataType[1];
    unsigned char  uszFormatIDOwner[2];
    unsigned char  uszFormatIDType[2];
    unsigned char  uszQuality[1];
    unsigned char  uszPurpose[1];
    unsigned char  uszBiometricType[4];
    unsigned char  uszProductIDOwner[2];
    unsigned char  uszProductIDType[2];
    unsigned char  uszCreationYear[2];
    unsigned char  uszCreationMonth[1];
    unsigned char  uszCreationDay[1];
    unsigned char  uszCreationHour[1];
    unsigned char  uszCreationMinute[1];
    unsigned char  uszCreationSecond[1];
    unsigned char  uszSubType[1];
    unsigned char  uszExpirationDateYear[2];
    unsigned char  uszExpirationDateMonth[1];
    unsigned char  uszExpirationDateDay[1];
    unsigned char  uszSBFormatOwner[2];
    unsigned char  uszSBFormatType[2];
    unsigned char  uszIndex[16];
};
#pragma pack(pop)

/**
 *  @brief This is the proprietary version of the BIR Header used only by BDB
 */
#pragma pack(push)
#pragma pack(1)
struct _V100_ENC_BIR_HEADER_PROPRIETARY
{
    unsigned char  uszHdLength[4];         /* < Header Size + ST_BBXBIO_DATA, minus 4 bytes of this field (uint) and converted to uchar[] > */
    unsigned char  uszHeaderVersion[4];
    unsigned char  uszBIRDataType[1];
    unsigned char  uszFormatIDOwner[2];
    unsigned char  uszFormatIDType[2];
    unsigned char  uszQuality[1];
    unsigned char  uszPurpose[1];
    unsigned char  uszBiometricType[4];
    unsigned char  uszProductIDOwner[2];
    unsigned char  uszProductIDType[2];
    unsigned char  uszCreationYear[2];
    unsigned char  uszCreationMonth[1];
    unsigned char  uszCreationDay[1];
    unsigned char  uszCreationHour[1];
    unsigned char  uszCreationMinute[1];
    unsigned char  uszCreationSecond[1];
    unsigned char  uszSubType[1];
    unsigned char  uszExpirationDateYear[2];
    unsigned char  uszExpirationDateMonth[2];
    unsigned char  uszExpirationDateDay[2];
    unsigned char  uszSBFormatOwner[2];
    unsigned char  uszSBFormatType[2];
    unsigned char  uszIndex[16];
};
#pragma pack(pop)

typedef _V100_ENC_BIR_HEADER_PROPRIETARY ST_BBXBIO_BIR_HEADER;

/**
 * The Biometric Data Block (BDB) is defined as follows:
 * BDB = DataSize (4 bytes) + Data (DataSize bytes)
 */
struct _V100_ENC_BIO_DATA {
    u32   nDataSize;
    void* pData;
};

typedef _V100_ENC_BIO_DATA ST_BBXBIO_DATA;

/**
 * This is the structure representing a Biometric Information Record (BIR)
 * to support transporting biometric data as inputs and outputs when the
 * Record Mode is set to BIR_MODE.
 */
struct _V100_ENC_BIR
{
    _V100_ENC_BIR_HEADER stHeader;
    _V100_ENC_BIO_DATA   stBiometricData;
    _V100_ENC_BIO_DATA   stSecurityBlock;
};

typedef _V100_ENC_BIR ST_BBXBIO_BIR;

/*********************** TM_BDB struct *************************************/

#ifndef V100_ENC_VERIFY_MATCH_RESULT
#define V100_ENC_VERIFY_MATCH_RESULT
typedef struct
{
    unsigned int    FMR;            // Match Score
    unsigned int    MatchResult;    // Boolean 0 for no, Positive for yes.
    u128            ANSOL;
    char            pad[8];
} _V100_ENC_VERIFY_MATCH_RESULT;
#endif

#pragma pack(push)
#pragma pack(1)
typedef struct
{
    uint16_t  type;
    uint16_t  width;
    uint16_t  height;
    uint32_t  size;
} ImageCGHeader_t;
#pragma pack(pop)
/*********************** End TM_BDB struct *********************************/


/********************** TM_TecBan, TM_MSK01 structs ************/
// Structures supporting V100_ENC_VERIFYMATCH_MANY


// Packet going in contains (opaqely) SK[_V100_ENC_VERIFY_MANY_HDR + N*_V100_ENC_BIR_TEMPLATE], as well as DIGSIG of Opaque data.
// Device decrypts, validates DIGSIG and ANBIO, then starts verification capture(s).
#pragma pack(push)
#pragma pack(8)
struct  _V100_ENC_VERIFY_MANY_HDR
{
#ifdef _VDSP
#pragma align 8
#endif
    u64      ANSOL;                            // ANSOL - Prevent Replay attacks
    u256     ANBIO;                            // Mutual Authentication.
    uint     nNumberOfMatchAttempts;            // How many times should we attempt to match?
    uint     nNumberOfTemplatesToMatch;        // How many templates are we matching against?
    uint     FMRRequest;                        // What is the requested threshold?
    u8       zeroPad[12];
} ;
#pragma pack(pop)

struct _V100_ENC_BIR_TEMPLATE
{
    uint     nTemplateSize;
    u8       BIRRecord[512];
    u8       zeroPad[28];
};

// The result contains one _V100_ENC_VERIFY_MANY_RST_HDR, and a series of _V100_ENC_VERIFY_MANY_RESULT.
// Result is encryped SK[RES], and digitial signature is SHA256 calculated from entire opaque set.
// ANSOL is validated by the trusted secure endpoint.
#pragma pack(push)
#pragma pack(8)
struct _V100_ENC_VERIFY_MANY_RST_HDR
{
#ifdef _VDSP
#pragma align 8
#endif
    u64      ANSOL;                                // ANSOL
    uint     nNumberOfMatchesAttempted;            // How many result fields are there.
    u8       zeropad[20];
};
#pragma pack(pop)

struct _V100_ENC_VERIFY_MANY_RESULT
{
    u64      ANSOL;                                // Prevents replay attacks.
    uint     nMatchIndex;                        // Which input template does this refer to?
    uint     nFMRResult;                            // Resultant Score
    uint     nIsMatch;                            // Is it a match against the requested FMR?
    int      nSpoofResult;                        // Spoof Result
    u8       zeroPad[8];
};

/********************End TM_TecBan, TM_MSK01 struct(s) ***********/

/********************** TM_HYB02**********************************/

/*
**  Extended Key Area Keynames
*/
enum _V100_ENC_KEY_TYPE {
    KT_EXTKEY_VEND            = 0,          //
    KT_EXTKEY_CTK             = 1,          // Customer Provisioning Key.       [KeyMode]  [KeyMode]
    KT_EXTKEY_BTK             = 2,          // Back-end transport key.          FKL/RKL
    KT_EXTKEY_AES0            = 3,          // AES-256_1                        AES-256    FKL/RKL
    KT_EXTKEY_AES1            = 4,          // AES-256_2                        AES-256    FKL/RKL
    KT_EXTKEY_AES2            = 5,          // AES-128_1                        AES-128    FKL/RKL
    KT_EXTKEY_AES3            = 6,          // AES-128_2                        AES-128    FKL/RKL
    KT_EXTKEY_TDES0           = 7,          // Not declared in CP001
    KT_EXTKEY_TDES1           = 8,          // Not declared in CP001
    KT_EXTKEY_TDES2           = 9,          // TDES_1                           TDES-192   FKL/RKL
    KT_EXTKEY_TDES3           = 10,         // TDES_2                           TDES-192   FKL/RKL
    KT_EXTKEY_AES_VEND        = 11,         // Vendor/integrator key            AES-256    FKL/RKL
    KT_EXTKEY_KSN_0           = 12,         // Not declared in CP001            DUKPT_64   FKL/RKL  (Derived Unique Key per Transaction)
    KT_EXTKEY_KSN_1           = 13,         // Not declared in CP001            DUKPT_64   FKL/RKL  (Derived Unique Key per Transaction)
    KT_EXTKEY_SPARE_2         = 14,         // Spare key
    KT_EXTKEY_SPARE_3         = 15,         // Spare key
    KT_EXTKEY_HOST_PUBLIC     = 16,         // BPK (Back-end Public Key)        RSA_2048   FKL/RKL
    KT_EXTKEY_DEVICE_PUBLIC   = 17,         // Bio public key.                  RSA_2048   Device generated. Used only for customer provisioning.
    KT_EXTKEY_DEVICE_PRIVATE  = 18,         // Bio private key.                 RSA_2048   Device generated. Used only for customer provisioning.
    KT_EXTKEY_DEVICE_P        = 19,         // Bio private prime P.             RSA_1024   Device generated. Used only for customer provisioning.
    KT_EXTKEY_DEVICE_Q        = 20,         // Bio private prime Q.             QRSA       Device generated. Used only for customer provisioning.
    KT_EXTKEY_PUBLIC_EXP      = 21,         // Back-end public exponent.        RSA        FKL/RKL
    KT_EXTKEY_PRIVATE_EXP     = 22,         // Bio private exponent.            RSA        Device generated. Used only for customer provisioning.
    KT_EXT_LAST,                            //
    KT_EXT_DSK                = 0x1000,     // Device generated session key.    AES-256    Volatile Device generated.
    KT_EXT_BSK                = 0x1001,     // Back-end generated session key.  KeyMode    Volatile Back-end generated.
    KT_EXT_SP                 = 0x1002,     // Reserved slot.

    // used by configurations that support the original keymap (aka Master/Session Key configurations):
    KT_MSK_MKD                = 0x2001, // Master Key, Diversified
    KT_MSK_SK                 = 0x2003  // Session Key
};

/*
 * Types of FKL modes available
 * Selected using CMD_SET_OPTION for V40x sensors with OPTION_SET_FACTORY_KEY_LOAD_MODE
 */
enum _V100_FACTORY_KEY_LOAD_MODE
{
    FACTORY_KEY_LOAD_COMPLETE = 0x0,
    FACTORY_KEY_LOAD_RESTORE  = 0x1,   // DEBUG MODE ONLY
};

/*
** Options
*/
enum _V100_ENC_OPTION_TYPE
{
    OPTION_SET_CRYPTO_MODE              = 0x2004, // Not supported
    OPTION_SET_FACTORY_KEY_LOAD_MODE    = 0x2008,
    OPTION_GENERATE_ASYMETRIC_KEYS      = 0x2009,
    OPTION_SET_TEMPLATE_RECORD_MODE     = 0x200A,
};

enum _V100_ENC_KEY_MODE
{
    KM_MODE_NONE           = 0,        //
    KM_AES_256_CBC         = 1,        // AES-256 using Cipher Block Chaining (CBC) cipher mode
    KM_AES_128_CBC         = 2,        // AES-128 using Cipher Block Chaining (CBC) cipher mode
    KM_TDES_ABA_ECB        = 3,        // Two-Key TDES (ABA Key Format) using Electronic Cookbook (ECB) cipher mode
    KM_TDES_ABA_CBC        = 4,        // Two-Key TDES (ABA Key Format) using Cipher Block Chaining (CBC) cipher mode
    KM_TDES_ABC_ECB        = 5,        // Three-Key TDES (ABC Key Format) using Electronic Cookbook (ECB) cipher mode
    KM_TDES_ABC_CBC        = 6,        // Three-Key TDES (ABC Key Format) using Cipher Block Chaining (CBC) cipher mode
    KM_RSA_2048_v15        = 0x1000,    // RSA-2048 (version 1.5)
    KM_RSA_2048_v21        = 0x1001,    // RSA-2048 (version 2.1)
    KM_DUKPT_IPEK_128      = 0x1002,    // DUKPT - Initial Pin Encryption Key
    KM_DUKPT_KSN_64        = 0x1003,    // DUKPT - Key Serial Number
};

/**
 * @brief Strong typed ENC_KEY_MODE class
 *
 */
enum class V100_ENC_KEY_MODE
{
    KM_MODE_NONE           = 0,        //
    KM_AES_256_CBC         = 1,        // AES-256 using Cipher Block Chaining (CBC) cipher mode
    KM_AES_128_CBC         = 2,        // AES-128 using Cipher Block Chaining (CBC) cipher mode
    KM_TDES_ABA_ECB        = 3,        // Two-Key TDES (ABA Key Format) using Electronic Cookbook (ECB) cipher mode
    KM_TDES_ABA_CBC        = 4,        // Two-Key TDES (ABA Key Format) using Cipher Block Chaining (CBC) cipher mode
    KM_TDES_ABC_ECB        = 5,        // Three-Key TDES (ABC Key Format) using Electronic Cookbook (ECB) cipher mode
    KM_TDES_ABC_CBC        = 6,        // Three-Key TDES (ABC Key Format) using Cipher Block Chaining (CBC) cipher mode
    KM_RSA_2048_v15        = 0x1000,    // RSA-2048 (version 1.5)
    KM_RSA_2048_v21        = 0x1001,    // RSA-2048 (version 2.1)
    KM_DUKPT_IPEK_128      = 0x1002,    // DUKPT - Initial Pin Encryption Key
    KM_DUKPT_KSN_64        = 0x1003,    // DUKPT - Key Serial Number
};

struct _V100_CAPTURE_STATS
{
    u32 nImageArea;
    u8 nImageQuality;
    u8 nImageQualityVersion;
    u8 nImageMinutiaCount;
    u8 nEnrollQuality;
    u8 nEnrollQualityVersion;
    u8 _reserved_1;
    u8 _reserved_2;
    u8 _reserved_3;
    u32 _reserved_4;
};

/**********************End TM_HYB02**********************************/


#endif // __V100_ENC_TYPES